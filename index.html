<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Universal Training Timer</title>

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0f172a">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="UniTimer">

    <!-- Icons -->
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0OCIgZmlsbD0iIzBmMTcyYSIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iNjAiIHI9IjMwIiBmaWxsPSJub25lIiBzdHJva2U9IiMzYjgyZjYiIHN0cm9rZS13aWR0aD0iOCIvPjxwYXRoIGQ9Ik01MCAzMHYxME01MCA2MGwyMC0yMCIgc3Ryb2tlPSIjZmZmIiBzdHJva2Utd2lkdGg9IjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjwvc3ZnPg==">
    <link rel="apple-touch-icon"
        href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48cmVjdCB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgcng9IjEyOCIgZmlsbD0iIzBmMTcyYSIvPjxjaXJjbGUgY3g9IjI1NiIgY3k9IjI4MCIgcj0iMTYwIiBmaWxsPSJub25lIiBzdHJva2U9IiMzYjgyZjYiIHN0cm9rZS13aWR0aD0iNDAiLz48cGF0aCBkPSJNMjU2IDEyMHY0ME0yNTYgNDAwdjQwTTQwMCAyODBoLTQwTTI0MCAyODBoLTgwIiBzdHJva2U9IiMzYjgyZjYiIHN0cm9rZS13aWR0aD0iNDAiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNTYgMjgwbDgwLTgwIiBzdHJva2U9IiNmZmYiIHN0cm9rZS13aWR0aD0iMjQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0xOTIgODB2NDBoMTI4VjgwSDI1NnoiIGZpbGw9IiMzYjgyZjYiLz48L3N2Zz4=">

    <!-- CDNs for React, Babel, and Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
            color: white;
            margin: 0;
            overflow: hidden;
            height: 100vh;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #root {
            height: 100%;
        }

        html,
        body {
            position: fixed;
            overflow: hidden;
            width: 100%;
        }
    </style>
</head>

<body>
    <div id="error-display"
        style="display:none; color: #ff6b6b; padding: 20px; font-family: monospace; z-index: 9999; position: fixed; top: 0; left:0; width: 100%; background: rgba(0,0,0,0.9); white-space: pre-wrap;">
    </div>
    <script>
        window.onerror = function (msg, url, line, col, error) {
            var el = document.getElementById('error-display');
            el.style.display = 'block';
            el.innerText += 'ERROR: ' + msg + '\nLine: ' + line + '\n' + (error ? error.stack : '') + '\n\n';
        };
    </script>

    <div id="root"></div>

    <script type="text/babel" data-presets="env,react">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- types / constants ---
        const TimerMode = {
            SERIES: 'SERIES',
            CLUSTER: 'CLUSTER',
            EMOM: 'EMOM',
            TABATA: 'TABATA',
            BOXING: 'BOXING'
        };

        const PhaseType = {
            PREPARATION: 'PREPARATION',
            WORK: 'WORK',
            REST: 'REST',
            INTRA_REST: 'INTRA_REST',
            COMPLETED: 'COMPLETED'
        };

        // --- services/audioService.ts ---
        class AudioService {
            constructor() {
                this.ctx = null;
            }

            init() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
            }

            playTone(freq, duration, volume = 0.1) {
                this.init();
                if (!this.ctx) return;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);

                gain.gain.setValueAtTime(volume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + duration);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playCountdown() {
                this.playTone(440, 0.2); // A4
            }

            playStart() {
                this.playTone(880, 0.5); // A5
            }

            playEnd() {
                this.playTone(220, 0.5); // A3
            }

            playBoxingBell() {
                this.init();
                if (!this.ctx) return;
                [600, 800, 1200].forEach(f => this.playTone(f, 1.5, 0.05));
            }

            vibrate() {
                if ('vibrate' in navigator) {
                    navigator.vibrate(200);
                }
            }
        }

        const audioService = new AudioService();

        // --- utils/timerEngine.ts ---
        const generateSegments = (config) => {
            const segments = [];

            // Preparación
            if (config.prepTime > 0) {
                segments.push({
                    type: PhaseType.PREPARATION,
                    duration: config.prepTime,
                    label: '¡Prepárate!',
                    setIndex: 0,
                    totalSets: config.sets
                });
            }

            switch (config.mode) {
                case TimerMode.SERIES:
                case TimerMode.TABATA:
                    for (let i = 1; i <= config.sets; i++) {
                        segments.push({
                            type: PhaseType.WORK,
                            duration: config.workTime,
                            label: `Serie ${i}`,
                            setIndex: i,
                            totalSets: config.sets
                        });
                        if (i < config.sets) {
                            segments.push({
                                type: PhaseType.REST,
                                duration: config.restTime,
                                label: 'Descanso',
                                setIndex: i,
                                totalSets: config.sets
                            });
                        }
                    }
                    break;

                case TimerMode.CLUSTER:
                    const reps = config.repsPerSet || 1;
                    for (let i = 1; i <= config.sets; i++) {
                        for (let r = 1; r <= reps; r++) {
                            segments.push({
                                type: PhaseType.WORK,
                                duration: config.workTime,
                                label: `Serie ${i} - Rep ${r}`,
                                setIndex: i,
                                totalSets: config.sets,
                                repIndex: r,
                                totalReps: reps
                            });
                            if (r < reps) {
                                segments.push({
                                    type: PhaseType.INTRA_REST,
                                    duration: config.intraRestTime || 0,
                                    label: 'Micro Descanso',
                                    setIndex: i,
                                    totalSets: config.sets,
                                    repIndex: r,
                                    totalReps: reps
                                });
                            }
                        }
                        if (i < config.sets) {
                            segments.push({
                                type: PhaseType.REST,
                                duration: config.restTime,
                                label: 'Descanso entre Series',
                                setIndex: i,
                                totalSets: config.sets
                            });
                        }
                    }
                    break;

                case TimerMode.EMOM:
                    const totalSession = config.totalSessionTime || 600;
                    const interval = config.intervalTime || 60;
                    const totalIntervals = Math.floor(totalSession / interval);
                    for (let i = 1; i <= totalIntervals; i++) {
                        segments.push({
                            type: PhaseType.WORK,
                            duration: interval,
                            label: `Minuto ${i}`,
                            setIndex: i,
                            totalSets: totalIntervals
                        });
                    }
                    break;

                case TimerMode.BOXING:
                    for (let i = 1; i <= config.sets; i++) {
                        segments.push({
                            type: PhaseType.WORK,
                            duration: config.roundTime || 180,
                            label: `Asalto ${i}`,
                            setIndex: i,
                            totalSets: config.sets
                        });
                        if (i < config.sets) {
                            segments.push({
                                type: PhaseType.REST,
                                duration: config.restTime,
                                label: 'Descanso',
                                setIndex: i,
                                totalSets: config.sets
                            });
                        }
                    }
                    break;
            }

            return segments;
        };

        const formatTime = (seconds) => {
            if (seconds < 60) return seconds.toString();
            const m = Math.floor(seconds / 60);
            const s = seconds % 60;
            return `${m}:${s.toString().padStart(2, '0')}`;
        };

        // --- components/Icons.tsx ---
        const PlayIcon = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M5 3l14 9-14 9V3z" /></svg>
        );

        const PauseIcon = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z" /></svg>
        );

        const ResetIcon = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" /><path d="M3 3v5h5" /></svg>
        );

        const ChevronLeftIcon = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M15 18l-6-6 6-6" /></svg>
        );

        const TimerIcon = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10" /><polyline points="12 6 12 12 16 14" /></svg>
        );

        const SunIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="5" /><line x1="12" y1="1" x2="12" y2="3" /><line x1="12" y1="21" x2="12" y2="23" /><line x1="4.22" y1="4.22" x2="5.64" y2="5.64" /><line x1="18.36" y1="18.36" x2="19.78" y2="19.78" /><line x1="1" y1="12" x2="3" y2="12" /><line x1="21" y1="12" x2="23" y2="12" /><line x1="4.22" y1="19.78" x2="5.64" y2="18.36" /><line x1="18.36" y1="5.64" x2="19.78" y2="4.22" /></svg>
        );

        const MoonIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" /></svg>
        );

        // --- components/TimerSetup.tsx ---
        const TimerSetup = ({ mode, onStart, onBack, isDarkMode }) => {
            const getDefaultConfig = (m) => {
                switch (m) {
                    case TimerMode.SERIES: return { mode: m, sets: 4, workTime: 45, restTime: 60, prepTime: 5 };
                    case TimerMode.TABATA: return { mode: m, sets: 8, workTime: 20, restTime: 10, prepTime: 5 };
                    case TimerMode.CLUSTER: return { mode: m, sets: 3, workTime: 0, restTime: 180, prepTime: 5, intraRestTime: 15, repsPerSet: 5 };
                    case TimerMode.EMOM: return { mode: m, sets: 10, workTime: 0, restTime: 0, prepTime: 5, intervalTime: 60, totalSessionTime: 600 };
                    case TimerMode.BOXING: return { mode: m, sets: 3, workTime: 180, restTime: 60, prepTime: 5, roundTime: 180, warningTime: 10 };
                    default: return { mode: m, sets: 1, workTime: 60, restTime: 30, prepTime: 5 };
                }
            };

            const [config, setConfig] = useState(getDefaultConfig(mode));

            const handleChange = (field, value) => {
                setConfig(prev => ({ ...prev, [field]: value }));
            };

            const InputField = ({ label, field, value }) => {
                const isTimeField = field.includes('Time') || field.includes('Duration') || field === 'workTime' || field === 'restTime' || field === 'prepTime' || field === 'intraRestTime' || field === 'intervalTime' || field === 'totalSessionTime' || field === 'roundTime';

                return (
                    <div className="mb-6">
                        <label className={`block text-sm font-semibold mb-2 uppercase tracking-wider ${isDarkMode ? 'text-slate-400' : 'text-slate-500'}`}>
                            {label}
                        </label>
                        <div className="flex items-center gap-4">
                            <button
                                onClick={() => handleChange(field, Math.max(0, value - (isTimeField ? 5 : 1)))}
                                className={`w-12 h-12 rounded-xl flex items-center justify-center text-2xl font-bold border transition-colors ${isDarkMode ? 'bg-slate-800 text-white border-slate-700 active:bg-slate-700' : 'bg-white text-slate-900 border-slate-200 active:bg-slate-100 shadow-sm'
                                    }`}
                            >-</button>
                            <div className={`flex-1 rounded-xl h-12 flex items-center justify-center text-xl font-bold border ${isDarkMode ? 'bg-slate-900 text-white border-slate-700' : 'bg-slate-50 text-slate-900 border-slate-200'
                                }`}>
                                {isTimeField ? (
                                    <>
                                        {formatTime(value)}
                                        {value < 60 && <span className="text-sm ml-0.5 opacity-60">s</span>}
                                    </>
                                ) : value}
                            </div>
                            <button
                                onClick={() => handleChange(field, value + (isTimeField ? 5 : 1))}
                                className={`w-12 h-12 rounded-xl flex items-center justify-center text-2xl font-bold border transition-colors ${isDarkMode ? 'bg-slate-800 text-white border-slate-700 active:bg-slate-700' : 'bg-white text-slate-900 border-slate-200 active:bg-slate-100 shadow-sm'
                                    }`}
                            >+</button>
                        </div>
                    </div>
                );
            };

            const getModeTitle = () => {
                switch (mode) {
                    case TimerMode.SERIES: return "SERIES";
                    case TimerMode.CLUSTER: return "CLÚSTER";
                    case TimerMode.EMOM: return "EMOM";
                    case TimerMode.TABATA: return "TABATA";
                    case TimerMode.BOXING: return "BOXEO";
                    default: return mode;
                }
            }

            return (
                <div className={`min-h-screen p-6 flex flex-col transition-colors duration-300 ${isDarkMode ? 'bg-slate-950 text-white' : 'bg-slate-50 text-slate-900'}`}>
                    <header className="flex items-center mb-8">
                        <button onClick={onBack} className={`p-2 -ml-2 transition-colors ${isDarkMode ? 'text-slate-400 hover:text-white' : 'text-slate-500 hover:text-slate-900'}`}>
                            <ChevronLeftIcon />
                        </button>
                        <h1 className="ml-2 text-2xl font-black italic tracking-tighter uppercase">CONFIGURAR {getModeTitle()}</h1>
                    </header>

                    <div className="flex-1 overflow-y-auto pb-24">
                        {mode === TimerMode.SERIES && (
                            <>
                                <InputField label="Series" field="sets" value={config.sets} />
                                <InputField label="Trabajo" field="workTime" value={config.workTime} />
                                <InputField label="Descanso" field="restTime" value={config.restTime} />
                            </>
                        )}

                        {mode === TimerMode.TABATA && (
                            <>
                                <InputField label="Rondas" field="sets" value={config.sets} />
                                <InputField label="Trabajo" field="workTime" value={config.workTime} />
                                <InputField label="Descanso" field="restTime" value={config.restTime} />
                            </>
                        )}

                        {mode === TimerMode.CLUSTER && (
                            <>
                                <InputField label="Número de Series" field="sets" value={config.sets} />
                                <InputField label="Reps por Serie" field="repsPerSet" value={config.repsPerSet || 0} />
                                <InputField label="Micro Descanso (Intra-serie)" field="intraRestTime" value={config.intraRestTime || 0} />
                                <InputField label="Trabajo por Rep" field="workTime" value={config.workTime} />
                                <InputField label="Descanso entre Series" field="restTime" value={config.restTime} />
                            </>
                        )}

                        {mode === TimerMode.EMOM && (
                            <>
                                <InputField label="Intervalo" field="intervalTime" value={config.intervalTime || 60} />
                                <InputField label="Sesión Total" field="totalSessionTime" value={config.totalSessionTime || 600} />
                            </>
                        )}

                        {mode === TimerMode.BOXING && (
                            <>
                                <InputField label="Asaltos" field="sets" value={config.sets} />
                                <InputField label="Duración Asalto" field="roundTime" value={config.roundTime || 180} />
                                <InputField label="Descanso" field="restTime" value={config.restTime} />
                            </>
                        )}

                        <InputField label="Preparación" field="prepTime" value={config.prepTime} />
                    </div>

                    <button
                        onClick={() => onStart(config)}
                        className="fixed bottom-8 left-6 right-6 h-16 bg-blue-600 hover:bg-blue-500 rounded-2xl flex items-center justify-center gap-3 text-xl font-black text-white transition-all shadow-xl shadow-blue-900/20 active:scale-95"
                    >
                        <PlayIcon /> INICIAR ENTRENAMIENTO
                    </button>
                </div>
            );
        };

        // --- components/TimerActive.tsx ---
        const TimerActive = ({ config, onExit }) => {
            const [segments] = useState(() => generateSegments(config));
            const [currentSegmentIndex, setCurrentSegmentIndex] = useState(0);
            const [timeLeft, setTimeLeft] = useState(segments[0]?.duration || 0);
            const [isActive, setIsActive] = useState(true);
            const [isCompleted, setIsCompleted] = useState(false);

            const timerRef = useRef(null);

            const currentSegment = segments[currentSegmentIndex];

            const handleNextSegment = useCallback(() => {
                if (currentSegmentIndex < segments.length - 1) {
                    const nextIndex = currentSegmentIndex + 1;
                    setCurrentSegmentIndex(nextIndex);
                    setTimeLeft(segments[nextIndex].duration);
                    audioService.playStart();
                } else {
                    setIsCompleted(true);
                    setIsActive(false);
                    audioService.playEnd();
                }
            }, [currentSegmentIndex, segments]);

            useEffect(() => {
                if (isActive && timeLeft > 0) {
                    timerRef.current = setInterval(() => {
                        setTimeLeft((prev) => {
                            // Avisos sonoros
                            if (prev <= 4 && prev > 1) {
                                audioService.playCountdown();
                            }

                            if (prev <= 1) {
                                handleNextSegment();
                                return 0;
                            }
                            return prev - 1;
                        });
                    }, 1000);
                } else {
                    if (timerRef.current) clearInterval(timerRef.current);
                }

                return () => {
                    if (timerRef.current) clearInterval(timerRef.current);
                };
            }, [isActive, timeLeft, handleNextSegment]);

            const toggleTimer = () => setIsActive(!isActive);

            const resetTimer = () => {
                setCurrentSegmentIndex(0);
                setTimeLeft(segments[0].duration);
                setIsActive(false);
                setIsCompleted(false);
            };

            const getPhaseColors = () => {
                if (isCompleted) return 'bg-blue-600';
                switch (currentSegment?.type) {
                    case PhaseType.PREPARATION: return 'bg-yellow-500';
                    case PhaseType.WORK: return 'bg-green-500';
                    case PhaseType.REST:
                    case PhaseType.INTRA_REST: return 'bg-red-500';
                    default: return 'bg-slate-800';
                }
            };

            const progress = isCompleted ? 100 : ((currentSegment.duration - timeLeft) / currentSegment.duration) * 100;

            const getModeLabel = () => {
                switch (config.mode) {
                    case TimerMode.SERIES: return "SERIES";
                    case TimerMode.CLUSTER: return "CLÚSTER";
                    case TimerMode.EMOM: return "EMOM";
                    case TimerMode.TABATA: return "TABATA";
                    case TimerMode.BOXING: return "BOXEO";
                    default: return config.mode;
                }
            }

            return (
                <div className={`fixed inset-0 flex flex-col transition-colors duration-500 ${getPhaseColors()}`}>
                    {/* Header */}
                    <div className="p-4 flex items-center justify-between z-10">
                        <button onClick={onExit} className="p-2 bg-black/20 rounded-full text-white">
                            <ChevronLeftIcon />
                        </button>
                        <div className="text-white font-bold uppercase tracking-widest text-sm">
                            TEMPORIZADOR {getModeLabel()}
                        </div>
                        <button onClick={resetTimer} className="p-2 bg-black/20 rounded-full text-white">
                            <ResetIcon />
                        </button>
                    </div>

                    {/* Main Display */}
                    <div className="flex-1 flex flex-col items-center justify-center text-white px-4">
                        {!isCompleted ? (
                            <>
                                <div className="text-xl font-semibold opacity-90 mb-2 uppercase tracking-wide">
                                    {currentSegment?.label}
                                </div>
                                <div className={`font-black leading-none drop-shadow-2xl transition-all ${timeLeft >= 60 ? 'text-[8rem]' : 'text-[12rem]'}`}>
                                    {formatTime(timeLeft)}
                                </div>
                                <div className="mt-8 text-2xl font-bold flex gap-4 bg-black/10 px-6 py-2 rounded-full backdrop-blur-sm">
                                    <span>Serie {currentSegment?.setIndex} / {currentSegment?.totalSets}</span>
                                    {currentSegment?.repIndex && (
                                        <span>Rep {currentSegment?.repIndex} / {currentSegment?.totalReps}</span>
                                    )}
                                </div>
                            </>
                        ) : (
                            <div className="text-center animate-bounce">
                                <div className="text-6xl font-black mb-4">¡HECHO!</div>
                                <div className="text-xl">Gran sesión de entrenamiento.</div>
                            </div>
                        )}
                    </div>

                    {/* Bottom Controls */}
                    <div className="p-12 flex flex-col items-center z-10">
                        {!isCompleted && (
                            <button
                                onClick={toggleTimer}
                                className="w-24 h-24 bg-white text-black rounded-full flex items-center justify-center shadow-2xl active:scale-95 transition-transform"
                            >
                                {isActive ? <PauseIcon /> : <PlayIcon />}
                            </button>
                        )}
                        {isCompleted && (
                            <button
                                onClick={onExit}
                                className="px-8 py-4 bg-white text-black rounded-full font-bold shadow-2xl active:scale-95 transition-transform"
                            >
                                VOLVER AL INICIO
                            </button>
                        )}
                    </div>

                    {/* Progress Bar Background */}
                    <div className="absolute bottom-0 left-0 w-full h-2 bg-black/20">
                        <div
                            className="h-full bg-white/50 transition-all duration-1000 ease-linear"
                            style={{ width: `${progress}%` }}
                        />
                    </div>
                </div>
            );
        };

        // --- App.tsx ---
        const App = () => {
            const [view, setView] = useState('HOME');
            const [selectedMode, setSelectedMode] = useState(null);
            const [timerConfig, setTimerConfig] = useState(null);
            const [isDarkMode, setIsDarkMode] = useState(true);

            const handleSelectMode = (mode) => {
                setSelectedMode(mode);
                setView('SETUP');
            };

            const handleStartTimer = (config) => {
                setTimerConfig(config);
                setView('TIMER');
            };

            const goHome = () => {
                setView('HOME');
                setSelectedMode(null);
                setTimerConfig(null);
            };

            const ModeCard = ({ mode, title, description, colorClass }) => (
                <button
                    onClick={() => handleSelectMode(mode)}
                    className={`w-full mb-4 p-6 rounded-3xl flex flex-col items-start text-left transition-all active:scale-95 relative overflow-hidden group border ${isDarkMode
                            ? `bg-slate-900 border-slate-800 text-white ${colorClass}`
                            : `bg-white border-slate-200 text-slate-900 shadow-sm ${colorClass.replace('hover:border-', 'hover:border-')}`
                        }`}
                >
                    <div className="relative z-10">
                        <h3 className="text-2xl font-black italic tracking-tighter mb-1 uppercase">{title}</h3>
                        <p className={`text-sm leading-tight pr-12 ${isDarkMode ? 'text-slate-400' : 'text-slate-500'}`}>{description}</p>
                    </div>
                    <div className={`absolute top-1/2 -translate-y-1/2 right-4 opacity-10 group-hover:opacity-20 transition-opacity ${isDarkMode ? 'text-white' : 'text-slate-900'}`}>
                        <TimerIcon />
                    </div>
                </button>
            );

            return (
                <div className={`h-full transition-colors duration-300 overflow-hidden ${isDarkMode ? 'bg-slate-950' : 'bg-slate-50'}`}>
                    {view === 'HOME' && (
                        <div className="h-full flex flex-col p-6 overflow-y-auto">
                            <header className="mb-8 pt-4 flex justify-between items-start">
                                <div>
                                    <h1 className={`text-4xl font-black italic tracking-tighter leading-none ${isDarkMode ? 'text-white' : 'text-slate-900'}`}>
                                        UNIVERSAL<br />
                                        <span className="text-blue-500">TRAINING</span> TIMER
                                    </h1>
                                    <p className={`mt-2 text-sm font-medium ${isDarkMode ? 'text-slate-400' : 'text-slate-500'}`}>Selecciona tu modalidad</p>
                                </div>
                                <button
                                    onClick={() => setIsDarkMode(!isDarkMode)}
                                    className={`p-3 rounded-2xl border transition-all ${isDarkMode ? 'bg-slate-900 border-slate-800 text-yellow-400' : 'bg-white border-slate-200 text-slate-700 shadow-sm'
                                        }`}
                                >
                                    {isDarkMode ? <SunIcon /> : <MoonIcon />}
                                </button>
                            </header>

                            <div className="flex-1">
                                <ModeCard
                                    mode={TimerMode.SERIES}
                                    title="Series Tradicionales"
                                    description="Intervalos estándar de Trabajo/Descanso para fuerza o hipertrofia."
                                    colorClass="hover:border-blue-500"
                                />
                                <ModeCard
                                    mode={TimerMode.CLUSTER}
                                    title="Entrenamiento Clúster"
                                    description="Alta intensidad con micro-pausas dentro de la misma serie."
                                    colorClass="hover:border-purple-500"
                                />
                                <ModeCard
                                    mode={TimerMode.EMOM}
                                    title="EMOM"
                                    description="Every Minute on the Minute. Tu velocidad es tu descanso."
                                    colorClass="hover:border-orange-500"
                                />
                                <ModeCard
                                    mode={TimerMode.TABATA}
                                    title="TABATA"
                                    description="Quema grasa al máximo. 20s trabajo, 10s descanso."
                                    colorClass="hover:border-green-500"
                                />
                                <ModeCard
                                    mode={TimerMode.BOXING}
                                    title="BOXEO / MMA"
                                    description="Asaltos con avisos finales y sonidos de campana."
                                    colorClass="hover:border-red-500"
                                />
                            </div>

                            <footer className={`py-4 text-center text-[10px] font-bold uppercase tracking-widest ${isDarkMode ? 'text-slate-600' : 'text-slate-400'}`}>
                                Pantalla Siempre Activa • Grado Profesional
                            </footer>
                        </div>
                    )}

                    {view === 'SETUP' && selectedMode && (
                        <TimerSetup mode={selectedMode} onStart={handleStartTimer} onBack={goHome} isDarkMode={isDarkMode} />
                    )}

                    {view === 'TIMER' && timerConfig && (
                        <TimerActive config={timerConfig} onExit={goHome} />
                    )}
                </div>
            );
        };

        const rootElement = document.getElementById('root');
        if (!rootElement) {
            throw new Error("Could not find root element to mount to");
        }

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').then(registration => {
                    console.log('SW registrado con éxito:', registration.scope);
                }, err => {
                    console.log('Fallo en el registro del SW:', err);
                });
            });
        }

        const root = ReactDOM.createRoot(rootElement);
        root.render(
            <React.StrictMode>
                <App />
            </React.StrictMode>
        );

    </script>
</body>

</html>